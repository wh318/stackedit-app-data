
文章目录
- [第一章·绪论](#第一章·绪论)
	- [1.1数据库系统概述](#1.1数据库系统概述)
		- [1.1.1基本概念](#1.1.1基本概念)
		- [1.1.2数据管理技术的生产和发展](#1.1.2数据管理技术的生产和发展)
			- [人工管理](#人工管理)
			- [文件系统](#文件系统)
			- [数据库系统](#数据库系统)
	- [1.2数据模型](#1.2数据模型)
		- [1.2.1概念模型](#1.2.1概念模型)
			- [两个实体之间的联系](#两个实体之间的联系)
			- [同一个实体集内各实体之间的联系](#同一个实体集内各实体之间的联系)
		- [1.2.2数据模型组成要素](#1.2.2数据模型组成要素：)
			- [数据结构](#数据结构：)
			- [数据操作](#数据操作：)
			- [完整性约束条件](#完整性约束条件：)
		- [1.2.3关系模型数据结构](#1.2.3关系模型数据结构)
			- [关系模型的基本概念](#关系模型的基本概念：)
			- [关系模型的数据操作](#关系模型的数据操作：)
			- [关系模型优缺点](#关系模型优缺点：)
			- [层次模型](#层次模型)
	- [1.3数据库系统结构](#1.3数据库系统结构)
		- [开发人员角度](#开发人员角度)
		- [最终用户](#最终用户)
		- [1.3.1数据库系统模式](#1.3.1数据库系统模式)
			- [型：对某一类数据的结构和属性的说明](#型：对某一类数据的结构和属性的说明)
			- [值：是型的一个具体赋值](#值：是型的一个具体赋值)
			- [模式：](#模式：)
			- [数据库系统的三级模式结构：](#数据库系统的三级模式结构：)
			- [模式：（外模式、内模式（物理）、模式（逻辑））](#模式：（外模式、内模式（物理）、模式（逻辑））)
[三级模式与二级映像](#三级模式与二级映像)
[1.4数据库系统的组成](#1.4数据库系统的组成)
[第二章·关系数据库](#第二章·关系数据库)
[2.1 关系数据结构及形式化定义 关系数据结构及形式化定义](#2.1 关系数据结构及形式化定义 关系数据结构及形式化定义)
[2.1.1 关系](#2.1.1 关系)
[笛卡尔积](#笛卡尔积)
[关系](#关系)
[码：](#码：)
[基本关系的性质：](#基本关系的性质：)
[2.1.2 关系模式](#2.1.2 关系模式)
[2.1.3 关系数据库](#2.1.3 关系数据库)
[2.2 关系操作](#2.2 关系操作)
[常用的关系操作](#常用的关系操作)
[关系操作的特点](#关系操作的特点)
[2.3 关系的完整性](#2.3 关系的完整性)
[• 实体完整性 （必须满足）](#• 实体完整性 （必须满足）)
[• 参照完整性（必须满足）](#• 参照完整性（必须满足）)
[2.外码](#2.外码)
[• 用户定义的完整性](#• 用户定义的完整性)
[2.4 关系代数](#2.4 关系代数)
[广义笛卡尔积](#广义笛卡尔积)
[专门的关系运算](#专门的关系运算)
[实例](#实例)
[连接：](#连接：)
[自然连接：](#自然连接：)
[悬浮元组：](#悬浮元组：)
[外连接:](#外连接:)
[第三章·SQL语句](#第三章·SQL语句)
[更新](#更新)
[1.插入数据](#1.插入数据)
[插入单个元祖](#插入单个元祖)
[插入子查询结果](#插入子查询结果)
[2.修改数据](#2.修改数据)
[语句格式](#语句格式)
[修改某一个元组的值](#修改某一个元组的值)
[修改多个元组的值](#修改多个元组的值)
[带子查询的修改语句](#带子查询的修改语句)
[3.删除数据](#3.删除数据)
[语句格式](#语句格式)
[删除某一个元组的值](#删除某一个元组的值)
[删除多个元组的值](#删除多个元组的值)
[带子查询的删除语句](#带子查询的删除语句)
[4.视图](#4.视图)
[定义视图](#定义视图)
[定义视图](#定义视图)
[基于多个基表的视图](#基于多个基表的视图)
[基于视图的视图](#基于视图的视图)
[带表达式的视图](#带表达式的视图)
[建立分组视图](#建立分组视图)
[删除视图](#删除视图)
[视图作用](#视图作用)
[第七章·数据库设计](#第七章·数据库设计)
[7.1.3数据库设计的基本步骤](#7.1.3数据库设计的基本步骤)
[7.2.3数据字典](#7.2.3数据字典)
[7.3概念结构设计（重点）](#7.3概念结构设计（重点）)
[7.3.1概念模型](#7.3.1概念模型)
[7.3.2 E-R模型](#7.3.2 E-R模型)
[7.3.2概念结构设计](#7.3.2概念结构设计)
[E-R图的集成](#E-R图的集成)
[7.4逻辑结构设计](#7.4逻辑结构设计)
[第四章·数据库安全性](#第四章·数据库安全性)
[数据安全性：](#数据安全性：)
[计算机系统安全性：](#计算机系统安全性：)
[三类：](#三类：)
[安全标准简介：](#安全标准简介：)
[数据库安全性控制：](#数据库安全性控制：)
[第五章·数据库完整性](#第五章·数据库完整性)
[5.1实体完整性：](#5.1实体完整性：)
[5.2参照完整性](#5.2参照完整性)
[5.3用户定义的完整性](#5.3用户定义的完整性)
[5.4完整性约束命名子句](#5.4完整性约束命名子句)
[第十章·数据库恢复技术](#第十章·数据库恢复技术)
[10.1 事务的基本概念](#10.1 事务的基本概念)
[事务：](#事务：)
[定义事物：](#定义事物：)
[事物的特性（ACID特性）](#事物的特性（ACID特性）)
[10.2 数据库恢复概述](#10.2 数据库恢复概述)
[10.3 故障的种类](#10.3 故障的种类)
[事务故障](#事务故障)
[系统故障](#系统故障)
[介质故障](#介质故障)
[计算机病毒](#计算机病毒)
[10.4 恢复的实现技术](#10.4 恢复的实现技术)
[转储：](#转储：)
[登记日志文件](#登记日志文件)
[第十一章·并发控制](#第十一章·并发控制)
[1并发控制概述](#1并发控制概述)
[2封锁](#2封锁)
[3封锁协议](#3封锁协议)
[4活锁和死锁](#4活锁和死锁)
[5并发调度的可串行性](#5并发调度的可串行性)
[6两段锁协议](#6两段锁协议)
[介质故障](#介质故障)
[计算机病毒](#计算机病毒)
[10.4 恢复的实现技术](#10.4 恢复的实现技术)
[转储：](#转储：)
[登记日志文件](#登记日志文件)
[第十一章·并发控制](#第十一章·并发控制)
[1并发控制概述](#1并发控制概述)
[2封锁](#2封锁)
[3封锁协议](#3封锁协议)
[4活锁和死锁](#4活锁和死锁)
[5并发调度的可串行性](#5并发调度的可串行性)
[6两段锁协议](#6两段锁协议)
1.课程的考核
期末成绩70%

平时作业10%

超星平台上布置的作业
超星平台上的视频学习
课前测试
实验占10%

实验测试（12次）从超星平台上下载实验指导手册
实验报告
半期测试10%

旷课扣5分，迟到早退扣2分

2.数据库的运用
电子商务，超市，各种信息

数据来自数据库：修改后数据需要存储到数据库中

3.数据库学什么？
学习目的：基本概念和理论，SQL，管理维护技术，设计方法和应用

# 第一章·绪论
## 1.1数据库系统概述
### 1.1.1基本概念
|基本概念|描述|
|:-:|:-:|
|数据Data|数据库中存储的基本对象：<u>音乐，一句话，视频</u>（后期），信息存在的一种形式|
|数据模型|描述现实世界的方法，比如把人抽象成身高、体重…|
|数据模式|用某个模型描述的结果，比如用c语言编写出一个表|
|数据库DB|Database,简称DB是长期存储在计算机内，有组织，可共享的。支持企业各种应用开发，数据集合。对企业中各种单位实体及其他们之间的联系，进行建模，把它存储起来|
|数据库管理系统DBMS|位于用户和操作系统之间，就是软件。功能（定义、提供数据定义语言DDL、操纵、运行管理）|
|数据库系统DBS(database system)|计算机系统引入数据库之后的称呼，DBS = DB + DBMS(用户和数据库之间) + 用户 + 软硬件环境|
### 1.1.2数据管理技术的生产和发展
#### 人工管理
	40-50年代
	特点：数据不保存，没有软件对系统进行管理，不具有独立性
#### 文件系统
	50-60年代
	特点：
	有早期的存储设备：磁带，磁盘，文件系统，批处理
	数据可以长期保存
	数据具有共享性
	由文件系统管理数据
#### 数据库系统
	60年代末
	从文件系统到数据库系统，是一个大飞跃
	特点：
	数据结构化（与文件系统的本质关系）
	数据共享性高，冗余度低，
	数据独立性高，
	数据由DBMS统一控制：安全保护、完整、并发控制（对多用户的并发操作加以控制，防止相互干扰而得到错误的结果)
## 1.2数据模型
|世界|说明|
|:-:|:-:|
|现实|客观存在的对象，如人|
|信息|由概念模型描述，如人的身高、体重、性别、年龄|
|机器|将概念模型数字化|
==数据模型要求：能真实的模拟现实世界、容易为人所理解、便于在计算机上实现==

### 1.2.1概念模型
|基本概念|说明|
|:-:|:-:|
|实体Entity|客观存在的对象|
|属性Attribute|实体具有的某一特性|
|码Key|能唯一标识一个实体的（学号）|
|域Domain|属性的取值范围（如==整数==、{a-z}）|
|实体型|实体及其属性名集合，如学生（姓名、学号、性别）|
|实体集|同类实体比如研究生和本科生|
|联系|现实世界中内部及事物之间的联系|
#### 两个实体之间的联系
一对一联系、一对多联系、多对多联系（课程和学生）

#### 同一个实体集内各实体之间的联系
一对一联系（夫妻）、一对多联系（领导和职工）、多对多联系（课程和预选课）

### 1.2.2数据模型组成要素：
#### 数据结构：
- 数据组织==静态==
#### 数据操作：
- 增删改查==动态==
#### 完整性约束条件：
- （eg:限制性别男女）通用或专用

关于数据模型的讨论：
1. 层次模型不能直接表示哪一种联系？多对多
2. 网状模型的数据结构是什么？图
3. 层次模型和网状模型的查询效率如何，哪个更优？层次

### 1.2.3关系模型数据结构

#### 关系模型的基本概念：

关系（二维表）、元祖（表中的一行)、属性（表中的列）、主码（唯一确定主体属性的）
分量（表中的单个元素）、关系模式（学生（学号，姓名，年龄））、域（取值)
==不允许表中套表==

#### 关系的每一个分量必须是不可分的数据项

##### 关系模型的数据操作：
增删改查

#### 关系模型优缺点：
建立在严格的数据概念基础上
概念单一。数据结构简单、清晰
缺点：查询效率不如非关系模型高

#### 层次模型
一对多（树形结构）PCR

## 1.3数据库系统结构
### 开发人员角度
三级模式结构(数据库内部)

### 最终用户
1. 单用户数据库系统（不共享）
2. 主从式结构（一个用户带多个终端比如银行机房的主机和ATM机）
3. 分布式结果数据库（逻辑上整体，物理分布不同。优点：便于组织管理 缺点：效率低）
4. 客户/服务器（qq软件是客户，腾讯服务器。优点：减少数据传输量。缺点：“胖客户”：维护困难。改进：B/S结构。游览器)
5. 游览器-应用服务器/数据库服务器多层结构

### 1.3.1数据库系统模式
#### 型：对某一类数据的结构和属性的说明
#### 值：是型的一个具体赋值
>例如
学生记录：
（学号，姓名，性别，系别，年龄，籍贯）
一个记录值：
（ （201315130 ，李明，男，计算机系，19，江苏南京市） ，江苏南京市）

#### 模式：
外模式、内模式（物理）、模式（逻辑）
所有数据的一个共有的试图，比如很多张表组成的一个视图
==一个数据库只有一个内模式==

例如：在学生选课数据库模式中，包含学生记录、课程记
录和学生选课记录，一张包含了信息的表

#### 数据库系统的三级模式结构：



#### 三级模式与二级映像
==外模式/模式映像==
定义外模式与模式之间的对应关系（可以多个）

==模式/内模式映像==
唯一的，描述数据在磁盘上到底是怎么存的，比如一个表是用哈希文件，还是对文件来存，这种存储方式。

两层映象保证了数据库系统中的数据能够具有较高的逻
辑独立性和物理独立性。 辑独立性和物理独立性

## 1.4数据库系统的组成
- 数据库
- 数据库管理系统
- 应用程序
- 数据库管理员

当修改数据的存储方式时，用户程序也可以不变，这是数据的==物理独立性==

# 第二章·关系数据库
## 2.1 关系数据结构及形式化定义 关系数据结构及形式化定义
### 2.1.1 关系
#### 笛卡尔积
|笛卡尔积|给定一组域D<sub>1</sub>，D<sub>2</sub>，D<sub>3</sub>……D<sub>n</sub>,(允许某些域是相同的)。两两集合的乘积，所有排列组合的总和，==可以表示为一张二位表==，表中的每行对应笛卡尔积的一个元素，表中每列对应一个域|
|:-:|:-:|
|元组|表中的一行|
|分量|表中的单个元素（值）|
|基数|排列组合的总个数，也就是笛卡尔积中元组的个数|
|交换？|笛卡尔积不满足交换律D1D2≠D2D1|
#### 关系
笛卡尔积中取出的有实际意义的元组来构造的关系（二维表）

笛卡尔积的有限子集

属性：列名

#### 码：
|候选码|某一（多个）属性值能唯一确定一个元组，该属性组为候选码|
|:-:|:-:|
|全码|所有的属性是候选码，所有属性算上才能决定一条元组|
|主码|若一个关系有多个候选码，选定一个为主码|
|主属性|候选码的各个属性|
|非主属性、非码属性|除了主属性之外的属性|

#### 基本关系的性质：
- 列同性质、顺序无所谓、任意两个元组不能完全相同、最小分量

### 2.1.2 关系模式
对关系的描述就是二维表结构

### 2.1.3 关系数据库
所有关系的集合构成的一个关系数据库

- 关系数据库的型: 关系数据库模式，是对关系数据库的描述。 关系数据库模式，是对关系数据库的描述。
- 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库。

## 2.2 关系操作
- 常用的关系操作
	- 查询操作：选择、投影、连接、除、并、差、交、笛卡尔积
		- 选择、投影、并、差、笛卡尔基是5种基本操作
	- 数据更新：插入、删除、修改

- 关系操作的特点
	-  集合操作方式：操作的对象和结果都是集合， 一次


## 2.3 关系的完整性
- 实体完整性 （必须满足）
若属性A是基本关系R的主属性，则属性A不能取空值（不知道，不存在，无意义）的值。==实体完整性规则规定基本关系的所有主属性都不 能取空值==

- 参照完整性（必须满足）
参照完整性要求关系中不允许引用不存在的实体。即参照的关系中的属性值必须能够在被参照关系找到或者取空值
	
1. 关系间的引用（一对多、多对多【学生实体及其内部的领导联系】）

	学生关系引用了专业关系的主码“专业号”。 学生关系中的“专业号”值必须是确实存在的专业

2. 外码

	在参照关系R中的候选键中的一个属性（不是其主键），中选一个对应被参照关系中的主键，则选出来的那个叫外码）

	外码必须是本关系的一个或一组属性；

	外码不是本关系的码；

	外码与另一个关系（可能是同一关系）的主码相对应；

-  用户定义的完整性
	- 唯一值约束（UNIQUE）；
	- 非空值约束（NOT NULL）；
	- 检查约束（CHECK）；
	- 缺省值约束（DEFAULT）。

## 2.4 关系代数
### 广义笛卡尔积
排列组合

### 专门的关系运算
|关系运算|说明|
|:-:|:-:|
|选择|选择又称为限制。它是在关系R中选择满足给定条件的各元组==从行的角度进行的运算==，记作σF（R）={ t∈R ∧ F(t)=‘真’}
投影|关系R上的投影是从R中选择出若干属性列组成新的关系。从==列的角度进行的运算==，有可能删除某些元组，避免重复，记作： ΠA（R）={t[A] \|t ∈R }|
|连接|θ连接是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。这种运算形式称作θ连接|
|除|把它看作寻找供应商|
### 实例
#### 连接：
 步骤一（1）求R×S;(2)选择R中属性A和S中属性B满足条件的元组组成新关系即为连接运算的结果。

#### 自然连接：
 一种特殊的等值连接，它要求两个 关系中进行比较的分量必须是相同的属 性组，并且 在结果中把重复的属性列去掉

#### 悬浮元组：
 自然连接时，舍弃的元组

#### 外连接:
- 如果把悬浮元组也保存在结果关系中，而在其他属 性上填空值(Null)，就叫做外连接
- 左外连接：只保留左边关系R中的悬浮元组
- 右外连接： 只保留右边关系S中的悬浮元组


# 第三章·SQL语句
## 1.1、SQL概述
### 1.1.1、什么是SQL
结构化查询语言 (Structured Query Language，SQL)是专门用来与数据库通信的语言，它可以帮助用户操作关系数据库。

### 1.1.2、SQL的特点
- SQL不是某个特定数据库供应商专有的语言
- SQL简单易学
- SQL强大、灵活，可以进行非常复杂和高级的数据库操作

### 1.1.3、SQL的组成
- 数据查询
- 数据定义
数据定义语言 (Data DefinitionLanguage，DDL)
	- CREATE：创建数据库或数据库对象
	- ALTER：对数据库或数据库对象进行修改
	- DROP：删除数据库或数据库对象
- 数据操纵
数据操纵语言 (Data ManipulationLanguage，DML)
	- SELECT：从表或视图中检索数据
	- INSERT：将数据插入到表或视图中
	- UPDATE：修改表或视图中的数据
	- DELETE：从表或视图中删除数据
- 数据控制
数据控制语言 (Data Control Language，DCL)
	- GRANT：用于授予权限
	- REVOKE：用于收回权限
- 嵌入式和动态SQL规则
嵌入式和动态SQL规则规定了SQL语句在高级语言程序设计中使用的规范方法，以便适应较为复杂的应用。

- SQL调用和会话规则
SQL调用和会话规则
  ```mermaid
	graph LR;
	SQL调用---SQL例程;
	SQL调用---调用规则;
  ```
  以便提高SQL的灵活性、有效性、共享性以及使SQL具有更多的高级语言的特征

## 1.2、MySQL预备知识
### 1.2.1、MySQL使用基础
关系数据库管理系统(R**DBMS**)
**优点**: 体积小、速度快、开放源代码、遵循GPL
  ```mermaid
	graph LR;
	Linux---LAMP;
	Apache---LAMP;
	Apache---WAMP;
	Windows---WAMP;
	LAMP---MysQL;
	WAMP---MysQL;
	LAMP---PHP/Perl/Python;
	WAMP---PHP/Perl/Python;
  ```

### 1.2.2、MySQL扩展语言要素
- 常量:
也称字面值或标量值
用单引号或双引号括起来的字符序列，分为ASCII字符串常量和Unicode字符串常量

- 变量
	- 用户变量
		-<font color=orange> **用户变量**</font>前常添加<font color=orange>**一个符号@**</font>，用于将其与列名区分开
	- 系统变量
		- 大多数<font color=orange>**系统变量**</font>应用于其他SQL语句中时，必须在系统变量前添加<font color=orange>**两个@**</font>

- 运算符
	|运算符|符号（功能）|
	|:-:|:-:|
	|算术运算符|+(加)、-(减)、*(乘)、/(除)、%(求模)|
	|位运算符|&(位与)、\|( 位或)、( 位异或)、~( 位取反 )、>>(位右移)、<<(位左移)|
	|比较运算符|=(等于 )、>(大于 )、<( 小于 )、>=(大于等于 )、<=(小于等于)、<>(不等于)、!=(不等于)、<=>( 相等或都等于空 )|
	|逻辑运算符|NOT或! ( 逻辑非)、AND或&& ( 逻辑与)、OR或\|\| ( 逻辑或)、XOR (逻辑异或)|

- 表达式
表达式是常量、变量、列名、复杂计算、运算符和函数的组合。
	1. 字符型表达式
	2. 数值型表达式
	3. 日期型表达式

- 内置函数
	|函数|表达式|
	|:-:|:-:|
	|数学函数|ABS()、ROUND()、POWER()、SQRT()、RAND()......|
	|聚合函数|COUNT()、SUM()、AVG()、MAX()、MIN().....|
	|字符串函数|ASCII()、CONCAT()、SUBSTRING()、UPPER()、LOWER()、REPLACE()......|
	|日期和时间函数|NOW()、DAY()、MONTH()、YEAR().....|
	|加密函数|ENCODE()、MD5()、SHA1()、SHA2()......|
	|控制流程函数|IF()、CASE、.....|
	|格式化函数|FORMAT()......|
	|类型转换函数|CAST0)......|
	|系统信息函数|USER()......|

## 1.3、数据定义
### 1.3.1、数据库模式定义
#### 1.3.1.1、创建数据库
使用CREATE DATABASE或CREATE SCHEMA语句
```sql
CREATE{DATABASEISCHEMATIIF NOT EXISTS] db_name
[DEFAULT]CHARACTER SET[=]charset_name
|[DEFAULT]COLLATE[=]collation_name;
```
- IF NOT EXISTS：创建数据库前进行判断
- db name：标示具体的数据库命名
- DEFAULT：指定默认值
- CHARACTER SET：指定数现库字符集(Charset)
- COLLATE：指定字符集的校对规则

**注：[ ] 标示其内容为可选项； | 用于分隔花括号中的选择项**
示例：
```sql
mysql> CREATE DATABASE my_data;
Query 0K，1 row affected (0. sec)
```

#### 1.3.1.2、查看数据库
```sql
SHOW {DATABASESISCHEMAS} [LIKE'pattern'|WHERE expr]
```
- LIKE关键字用于匹配指定的数据库名称
- WHERE从句用于指定数据库名称查询范围的条件

示例：
```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| my_data			 |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.01 sec)
```




```sql
create database Example;
use example;
create table student
        (Sno CHAR(5) NOT NULL UNIQUE,
         Sname CHAR(20) UNIQUE,
         Ssex INT,
         Sdept CHAR(15);
        )
select * from student;

alter table student add scome datetime;
alter table student alter column Sage SMALLINT;

alter table student drop constraint;
alter table student drop column scome;

drop table student;
create unique index Stusno ON Student(Sno);
drop index stusno on student;
create unique index Stusno ON Student(Sno);

insert into Student(Sno,sname,Ssex,Sage,Sdept)
values('95001','陈东','M','IS');

insert into Student
values('95002','张成名','男','18','CS');
```

# 第七章·数据库设计
手工试凑法

规范设计法：

Ø新奥尔良（New Orleans）方法

Ø基于E-R模型的数据库设计方法

Ø3NF（第三范式）的设计方法 Ø面向对象的数据库设计方法

Ø统一建模语言（UML）方法

### 7.1.3数据库设计的基本步骤
• 需求分析

是否做得充分与准确，决定了构建数据库的速度和质量

• 概念结构设计

通过对用户需求进行综合、归纳与抽象，形成一个独立于具体 数据库管理系统的概念模型

• 逻辑结构设计

将概念结构转换为某个数据库管理系统所支持的数据模型，并 对其进行优化(转换为表)

• 物理结构设计

为逻辑数据结构选取一个最适合应用环境的物理结构 ，包括存储结构和存取方法

• 数据库实施

根据逻辑设计和物理设计的结果构建数据库 编写与调试应用程序 组织数据入库并进行试运行

• 数据库运行和维护

经过试运行后即可投入正式运行 在运行过程中必须不断对其进行评估、调整与修改

需求分析和概念设计独立于任何数据库管理系统

逻辑设计和物理设计与选用的数据库管理系统密切相关

### 7.2.3数据字典
数据项（最小单位）

不可再细分比如学生的学号、成绩

数据结构

反应了数据之间的组成关系，比如学生可以看做一个数据结构由姓名、学号、、、等数据项

组成

数据流

数据传输的路径（对数据动态的描述），比如订单

数据存储（静态）

数据结构在数据库中的存储位置，比如库存。

处理过程

是一个动作，比如输入所有学生信息，按照需求分配宿舍

## 7.3概念结构设计（重点）
### 7.3.1概念模型
将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程

和用户进行交流、易于更改、易于向各个数据模型转换

用ER模型描述概念模型

### 7.3.2 E-R模型
实体之间的联系：一对一（班级与班长）、一对多（班级与学生一对多）、多对多（课程与学生）；

联系关系到几个实体就叫做几元联系

E-R图

实体	属性	联系	连接方式
矩形	圆形	菱形	无向边连接
第一步：确定有哪些实体，画出五个实体

第二步：判断每个实体间有什么联系

### 7.3.2概念结构设计
实体与属性的划分原则：现实世界的事物能作为属性对待就当属性（属性优先）

两条准则：不可再分不能描述，不能与其他属性有联系

E-R图的集成
合并。解决各分E-R图之间的冲突，将分E-R图合并起来生 成初步E-R图。

属性冲突	命名冲突	结构冲突
属性域冲突（类型、取值范围、取值集合）	同名异义	同一对象在不同应用中具有不同的抽象。（有的当做实体，有的当做属性）
属性取值单位冲突（公斤、斤）	异 名同义	同一实体在不同子系统的E-R图中所包含的属性个数和属性 排列次序不完全相同
命名冲突	实体间的联系在不同的E-R图中为不同的类型
修改和重构。消除不必要的冗余，生成基本E-R图。

• 所谓冗余的数据是指可由基本数据导出的数据， 冗余的联系是指可由其他联系导出的联系。

• 消除冗余主要采用分析方法，即以数据字典和 数据流图为依据，根据数据字典中关于数据项 之间逻辑关系的说明来消除冗余。

## 7.4逻辑结构设计
### 7.4.1E-R图向关系模型的转换

将概念模式转换为关系模式

转换原则：

实体转化为独立的关系模式
属性对应属性，码对应码

一对一转换：最好合并到某一 端，不要转换为独立的
一对多转换：独立、合并到N端（一端的码和联系的属性放进n端 ）
多对多转换：两个多端的码合并（独立）
多元联系转换为独立的关系模式
E-R图不能出现业务流程

第四章·数据库安全性
数据安全性：
防止非法用户使用数据库，造成数据泄露、更改或破坏。

计算机系统安全性：
三类：
技术安全（软硬件）、管理安全（房间失火）、政策法律安全

安全标准：TCSEC.桔皮书(针对整个计算机系统) TDI 紫皮书（将TCSEC*扩展到数据库管理系统。）

数据库有哪些安全控制机制？

安全标准有那几个？

安全标准简介：
D级	C1级	C2级	B1级	B2级	B3级	A1级
一切不符合最高标准的系统EG:DOS	非常初级的自主安全保护eg:DAC	安全产品的最低档 次	标记安全保护。MAC强制存取控制	结构化保护，有主体和客体实施DAC和MAC，（稀少）	安全域	验证设计，即提供B3级保护的同时给出系统的形式
注：B2以上的系统还处于理论研究阶段，应用多限于一些特殊的部门如军队等。

数据库安全性控制：
应用：用户标识和鉴定（输入用户名和密码）—》DBMS：存取控制-----》

存取控制:定义存取

用户标识与鉴别	存取控制	自主存取控制方法	授权与回收	数据库角色	强制存取控制方法
合法用户标识	先对每个用户定义存储权限	不同用户不同数据对象不同权限	DBA和表的建立者定义		先进行DAC检查，通过DAC检查的数据对象再由系统
用户名/口令	自主存取控制DAC，强制存取控制MAC	能够通过授权机制有效地控制其他用户对敏感数 ，可能存在数据的无意泄露	SQL语句；GRANT(授予权限),REVOKE（收回权限）		
 --GRANT语句的一般格式：
 GRANT <权限>[,<权限>]...
 [ON <对象类型> <对象名>] 
 TO <用户>[,<用户>]...
 [WITH GRANT OPTION]; --获得某种权限的用户还可以把这种权限再授予别的用户
-- GRANT功能：将对指定操作对象的指定操作权限授予 指定的用户。
1
2
3
4
5
6
先进行DAC检查，通过DAC检查的数据对象再由系统

进行MAC检查，只有通过MAC检查的数据对象方可存

取。

# 第五章·数据库完整性
完整性：防止合法用户输入输出防止数据破坏

安全性：防止非法用户

完整性控制机制：约束条件、完整性检查机制、违约处理

## 5.1实体完整性：
primary key 定义，表级完整性约束或列级完整性约束
1
## 5.2参照完整性
1，外码能否接受空值（如果是另一个关系的主属性就不允许取空值）

2，在被参照完整性中删除元组的问题

级联删除
受限删除
置空值删除
3，在参照关系中插入元组时

受限
递归
4，修改关系中的主码

级联修改（on update cascade（在定义表的时候加上这句话才能进行级联） 修改它，另一个参照它的也跟着修改）
受限修改
置空值修改
## 5.3用户定义的完整性
check约束（可列级，可表级）

列级非空，列级单一只能作为列级约束

--元组上的约束条件的定义 • CHECK短语 
CREATE TABLE Student     
(Sno       CHAR(5) ，        
 Sname  CHAR(20)  NOT NULL，      
 Ssex      CHAR(1) ，      
 Sage      INT，         
 Sdept    CHAR(15)，    
 PRIMARY KEY （Sno）   
 CHECK （Ssex=‘女’ OR Sname NOT LIKE ‘Ms.%’）         )； 
 --元组上的约束条件检查和违约处理
1
2
3
4
5
6
7
8
9
10
## 5.4完整性约束命名子句
--完整性约束命名子句 
CREATE TABLE Student  
(Sno       NUMERIC（6） 
  CONSTRAINT C1 CHECK（Sno BETWEEN 90000 AND99999）， 
  Sname  CHAR(20) CONSTRAINT C2 NOT NULL，             Ssex  CHAR(2)     
  CONSTRAINT C3 CHECK（Ssex IN （’男‘，’女‘）），         CONSTRAINT C4      
  PRIMARY KEY （Sno）      )；
 
 
 -- 修改表中的完整性限制 ALTER TABLE Student DROP CONSTRAINT C4；
ALTER TABLE Student ADD CONSTRAINT C1 CHECK（Sno BETWEEN 900000 AND 999999）；
1
2
3
4
5
6
7
8
9
10
11
# 第十章·数据库恢复技术
## 10.1 事务的基本概念
事务：
​ 一个事务可以是一条SQL语句，一组 SQL语句或整个程序

（ 一个应用程序通常包含多个事务）

定义事物：
BEGIN TRANSACTION
SQL 语句1  
SQL 语句2 
.....
COMMIT--事务正常结束 


BEGIN TRANSACTION
SQL 语句1  
SQL 语句2 
.....
ROLLBACK--事务异常终止 
1
2
3
4
5
6
7
8
9
10
11
12
事物的特性（ACID特性）
原子性（Atomicity）	一致性（Consistency）	隔离性（Isolation）	持续性（永久）（Durability ）
·事务是数据库的逻辑工作单位 •事务中包括的诸操作要么都做，要么 都不做	数据库中只包含成功事务提交的结果	并发执行的各个事务之间不能互相干扰	一个事务一旦提交，它对数据库中数据的改变就应 该是永久性的
## 10.2 数据库恢复概述
数据库管理系统对故障的对策

•DBMS提供恢复子系统

• 保证故障发生后，能把数据库中的数据从错误状态 恢复到某种逻辑一致的状态

• 保证事务ACID
恢复技术是衡量系统优劣的重要指标

10.3 故障的种类
事务故障
某个事务在运行过程中由于种种原因未运行至正常 终止点就夭折了

输入数据有误
运算溢出
违反了某些完整性限制
某些应用程序出错
并行事务发生死锁
事务故障的恢复

发生事务故障时，夭折的事务可能已把对数据库的部分 修改写回磁盘
事务故障的恢复：撤消事务（UNDO）
强行回滚（ROLLBACK）该事务
清除该事务对数据库的所有修改，使得这个事务象根本 没有启动过一样
系统故障
系统故障常见原因

操作系统或DBMS代码错误
操作员操作失误
特定类型的硬件错误（如CPU故障）
突然停电
系统故障的恢复

清除尚未完成的事务对数据库的所有修改

• 系统重新启动时，恢复程序要强行撤消（UNDO）所 有未完成事务

将缓冲区中已完成事务提交的结果写入数据库

• 系统重新启动时，恢复程序需要重做（REDO）所有 已提交的事务

介质故障
计算机病毒
恢复操作的基本原理：冗余

• 利用存储在系统其它地方的冗余数据来重建数据库中 已被破坏或不正确的那部分数据

恢复的实现技术：复杂

• 一个大型数据库产品，恢复子系统的代码要占全部代 码的10%以上

## 10.4 恢复的实现技术
转储：
转储是指DBA将整个数据库复制到磁带或另一个磁盘上 保存起来的过程

登记日志文件
日志文件(log)是用来记录事务对数据库的 更新操作的文件

​ 以数据块或日志为单位

日记文件内容：

​ 开始标志、结束标志、所有更新操作、 与事务有关的内部更新操作

登记原则：

​ 登记的次序严格按并行事务执行的时间次序

​ 必须先写日志文件，后写数据库

第十一章·并发控制
1并发控制概述
多事物执行方式：串行、交叉并发、同时并发

并发操作带来的数据不一致性：丢失修改、不可重复读（不同值，【神秘消失，多数据记录】（幻影现象））、读‘’脏“数据

2封锁
在事务T释 放它的锁之前，其它的事务不能更新此数据对象

基本封锁类型：排他锁X锁、共享锁S锁

3封锁协议
一级：加X锁 不丢失修改

二级：加S锁，在操作结束后解锁释放 不丢失修改，不读‘’脏数据”

三级：在整个事务结束后解锁释放 不丢失修改，不读‘’脏数据” ， 可重复读

4活锁和死锁
活锁：先来先服务

死锁：多个事物互相等待的情形

方法：

预防死锁（一次封锁法（降低了并发度，实际上不可行）、顺序封锁法（也不可行）)
检测死锁：如果事物等待时间超过了约定时间，则确定发生了死锁。（等待图法）
解除死锁
5并发调度的可串行性
将所有事物串行起来的策略一定是正确的调度策略

当且仅当某结果与按某一次序串行执行结果相同

并发事物正确性准则：可串行性

如何保证并发操作的地调度正确？

6两段锁协议
1，在对任何数据进行读、写操作之前

明确的把事物加锁

将缓冲区中已完成事务提交的结果写入数据库

• 系统重新启动时，恢复程序需要重做（REDO）所有 已提交的事务

介质故障
计算机病毒
恢复操作的基本原理：冗余

• 利用存储在系统其它地方的冗余数据来重建数据库中 已被破坏或不正确的那部分数据

恢复的实现技术：复杂

• 一个大型数据库产品，恢复子系统的代码要占全部代 码的10%以上

## 10.4 恢复的实现技术
转储：
转储是指DBA将整个数据库复制到磁带或另一个磁盘上 保存起来的过程

登记日志文件
日志文件(log)是用来记录事务对数据库的 更新操作的文件

​ 以数据块或日志为单位

日记文件内容：

​ 开始标志、结束标志、所有更新操作、 与事务有关的内部更新操作

登记原则：

​ 登记的次序严格按并行事务执行的时间次序

​ 必须先写日志文件，后写数据库

# 第十一章·并发控制
1并发控制概述
多事物执行方式：串行、交叉并发、同时并发

并发操作带来的数据不一致性：丢失修改、不可重复读（不同值，【神秘消失，多数据记录】（幻影现象））、读‘’脏“数据

2封锁
在事务T释 放它的锁之前，其它的事务不能更新此数据对象

基本封锁类型：排他锁X锁、共享锁S锁

3封锁协议
一级：加X锁 不丢失修改

二级：加S锁，在操作结束后解锁释放 不丢失修改，不读‘’脏数据”

三级：在整个事务结束后解锁释放 不丢失修改，不读‘’脏数据” ， 可重复读

4活锁和死锁
活锁：先来先服务

死锁：多个事物互相等待的情形

方法：

预防死锁（一次封锁法（降低了并发度，实际上不可行）、顺序封锁法（也不可行）)
检测死锁：如果事物等待时间超过了约定时间，则确定发生了死锁。（等待图法）
解除死锁
5并发调度的可串行性
将所有事物串行起来的策略一定是正确的调度策略

当且仅当某结果与按某一次序串行执行结果相同

并发事物正确性准则：可串行性

如何保证并发操作的地调度正确？

6两段锁协议
1，在对任何数据进行读、写操作之前

明确的把事物加锁

满足两段锁协议一定是正确的调度，正确的调度不一定遵守两段锁协议

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5OTA0NTY1MDVdfQ==
-->